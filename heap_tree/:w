const [svgWidth, svgHeight] = [800, 600];
const pad = 50;
const menu = d3.select('section.menu-left');
const svg = d3.select('svg')
  .attr('width', svgWidth)
  .attr('height', svgHeight);
const h = new HeapTree(15, (a, b) => a > b);

svg.append('g')
  .classed('links', true);
svg.append('g')
  .classed('nodes', true);
const update = (heapData, transitionEnabled) => {
  const t = d3.transition()
    .duration(1000);
  const data = heapData.data;
  if (data.length === 0) return;
  const startY = -data[0].y;
  const links = svg.select('g.links')
    .classed('link', true)
    .attr('transform', `translate(${pad}, ${startY + pad/2})`)
    .selectAll('path')
    .data(data.slice(1), d => d.id);
  links.exit().remove();
  const linksEnter = links.enter()
    .append('path');
  linksEnter.attr('fill', 'none')
    .attr('stroke', '#000')
    .linkEnter.attr('d', d => `M${d.parent.x},${d.parent.y} L${d.parent.x},${d.parent.y}`);
  let linkMerge = linksEnter.merge(links);
  if (transitionEnabled) {
    linksEnter = linksEnter.transition(t)
  }
  linksEnter.attr('d', d => `M${d.parent.x},${d.parent.y} L${d.x},${d.y}`);

  const nodes = svg.select('g.nodes')
    .classed('node', true)
    .attr('transform', `translate(${pad}, ${startY + pad/2})`)
    .selectAll('g')
    .data(data, d => d.id);
  nodes.exit().remove();
  const nodesEnter = nodes.enter()
    .append('g');
  nodesEnter.append('circle')
    .attr('fill', '#fff')
    .attr('stroke', '#000');
  nodesEnter.append('text')
    .attr('text-anchor', 'middle')
    .attr('dominant-baseline', 'central')
    .text(d => d.val);
  let nodesMerge = nodesEnter.merge(nodes);
  if (transitionEnabled) {
      nodesMerge = nodesMerge.transition(t)
  }
  nodesMerge.attr('transform', d => `translate(${d.x},${d.y})`)
    .select('circle')
    .attr('r', heapData.radius);
}


const paddingRightContainer = menu.append('div')
  .classed('input-container', true);
const paddingRightSlider = paddingRightContainer.append('input')
  .attr('type', 'range')
  .attr('min', 0)
  .attr('max', 100)
  .attr('value', h.paddingRight)
const paddingRightSliderSpan = paddingRightContainer.append('span') 
  .text(h.paddingRight);
const changePaddingRight = () => {
  h.paddingRight = Number(paddingRightSlider.property('value'));
  update(h.toPosition(), false);
  paddingRightSliderSpan.text(h.paddingRight);
};
paddingRightSlider.on('input', changePaddingRight);
paddingRightSlider.on('change', changePaddingRight);

const paddingBottomContainer = menu.append('div')
  .classed('input-container', true);
const paddingBottomSlider = paddingBottomContainer.append('input')
  .attr('type', 'range')
  .attr('min', 0)
  .attr('max', 300)
  .attr('value', h.paddingBottom)
const paddingBottomSliderSpan = paddingBottomContainer.append('span') 
  .text(h.paddingBottom);
const changePaddingBottom = () => {
  h.paddingBottom = Number(paddingBottomSlider.property('value'));
  update(h.toPosition(), false);
  paddingBottomSliderSpan.text(h.paddingBottom);
};
paddingBottomSlider.on('input', changePaddingBottom);
paddingBottomSlider.on('change', changePaddingBottom);

const radiusContainer = menu.append('div')
  .classed('input-container', true);
const radiusSlider = radiusContainer.append('input')
  .attr('type', 'range')
  .attr('min', 0)
  .attr('max', 100)
  .attr('value', h.radius)
const radiusSliderSpan = radiusContainer.append('span') 
  .text(h.radius);
const changeRadius = () => {
  h.radius = Number(radiusSlider.property('value'));
  update(h.toPosition(), false);
  radiusSliderSpan.text(h.radius);
};
radiusSlider.on('input', changeRadius);
radiusSlider.on('change', changeRadius);

const a = '4 1 3 2 16 9 10 14 8 7'.split(' ')
  .map(d => Number(d));
const itr = new class {
  constructor(data) {
    this.cnt = 0;
    this.data = data;
  }
  get now() { return this.data[this.cnt]; }
  get hasNext() { return this.cnt < this.data.length; }
  next() { this.cnt++; }
}(a);
const pushButton = menu.append('input')
  .attr('type', 'button')
  .attr('value', 'push')
  .on('click', () => {
    if (itr.hasNext) {
      console.log(`pushed: ${itr.now}`);
      const arr = h.push(itr.now);
      itr.next();
      let i = 0;
      const timer = d3.interval(() => {
        if (i < arr.length) {
          update(arr[i], true);
          i++;
        } else {
          timer.stop();
        }
      }, 1000);
    }
  });
const popButton = menu.append('input')
  .attr('type', 'button')
  .attr('value', 'pop')
  .on('click', () => {
    const arr = h.pop();
    let i = 0;
    const timer = d3.interval(() => {
      if (i < arr.length) {
        update(arr[i], true);
        i++;
      } else {
        timer.stop();
      }
    }, 1000);
  });
update(h.toPosition(), false);

